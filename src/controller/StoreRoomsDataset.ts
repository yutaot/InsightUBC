import StoreDataset from "./StoreDataset";import {InsightDatasetKind, InsightError, Room, TableKind} from "./IInsightFacade";import * as parse5 from "parse5";import * as http from "http";import Log from "../Util";import {    assignRemainingRoomKeys,    getBuildingInfoFromTableNode,    getChildNodeWithGivenName,    getNodeWithGivenName} from "./StoreRoomsHtmlHelpers";export default class StoreRoomsDataset extends StoreDataset {    private httpGetUrl = "http://cs310.students.cs.ubc.ca:11316/api/v1/project_team012/";    public validateRootFolder(unzippedFile: any): boolean {        return "rooms/" in unzippedFile.files;    }    public determineDatasetKindObject(kind: InsightDatasetKind): any {        return {rooms: [], kind: kind};    }    public getBuildingsGeolocation(buildingAddress: string): Promise<any> {        let fullHttpGetUrl = this.httpGetUrl + encodeURIComponent(buildingAddress);        return new Promise((resolve) => http.get(fullHttpGetUrl, (response) => {            if (response.statusCode !== 200) {                return resolve(null);            }            let responseData = "";            response.on("data", function (chunk) {                responseData += chunk;            });            response.on("end", function () {                return resolve(JSON.parse(responseData));            });        }));    }    public roomHasNoMissingKeys(room: Room): boolean {        if (            (room.fullname) &&            (room.shortname) &&            (room.number) &&            (room.name) &&            (room.address) &&            (room.lat) &&            (room.lon) &&            (room.type) &&            (room.furniture) &&            (room.href)        ) {            return true;        } else {            return false;        }    }    public storeBuildingFileDataToMemory(        id: string, buildingFileData: string, roomsDatasets: any, buildingNameCodeAndAddress: any    ): Promise<void> {        let buildingFileHtmlTree = parse5.parse(buildingFileData);        let promise = this.getBuildingsGeolocation(buildingNameCodeAndAddress.address);        return promise.then((buildingGeolocationJson) => {            if (!buildingGeolocationJson || ("error" in buildingGeolocationJson)) {                return;            }            let roomTableNode = getNodeWithGivenName(buildingFileHtmlTree, "table", TableKind.Room);            let tableBodyNode: any = getChildNodeWithGivenName(roomTableNode, "tbody");            if (tableBodyNode && ("childNodes" in tableBodyNode)) {                for (let trNode of tableBodyNode.childNodes) {                    if (trNode && ("nodeName" in trNode) && trNode.nodeName === "tr" && ("childNodes" in trNode)) {                        let room: Room = {                            fullname: String(buildingNameCodeAndAddress.name),                            shortname: String(buildingNameCodeAndAddress.code),                            number: "",                            name: "",                            address: String(buildingNameCodeAndAddress.address),                            lat: Number(buildingGeolocationJson.lat),                            lon: Number(buildingGeolocationJson.lon),                            seats: 0,                            type: "",                            furniture: "",                            href: ""                        };                        assignRemainingRoomKeys(trNode, room, buildingNameCodeAndAddress.code);                        // TODO: If any attributes are missing, skip over the file...                        // if (this.roomHasNoMissingKeys(room)) {                        roomsDatasets[id].rooms.push(room);                        // }                    }                }            }        });    }    public getBuildingInfoFromIndexFile(indexFile: any): any {        return indexFile.async("string").then((indexFileData: string) => {            let indexFileHtmlTree = parse5.parse(indexFileData);            let buildingsTableNode = getNodeWithGivenName(indexFileHtmlTree, "table", TableKind.Building);            return getBuildingInfoFromTableNode(buildingsTableNode);        });    }    public readAllFilesAndStoreDatasetToMemory(        id: string, unzippedFiles: any, roomsDatasets: any, buildingInfoFromIndexFile: any,        readAllFilesPromises: any[], storeAllRoomsToMemoryPromises: any[]): any[] {        Object.keys(buildingInfoFromIndexFile).forEach((href) => {            let file = unzippedFiles.folder("rooms").file(href.substring(2));            if (file == null) {                return;            }            try {                let readFilePromise = file.async("string").then((fileData: string) => {                    let buildingCodeNameAndAddress = buildingInfoFromIndexFile[href];                    let storeRoomPromise = this.storeBuildingFileDataToMemory(                        id, fileData, roomsDatasets, buildingCodeNameAndAddress);                    storeAllRoomsToMemoryPromises.push(storeRoomPromise);                });                readAllFilesPromises.push(readFilePromise);            } catch (e) {                Log.trace("Failure to parse data for a file, skipping over...");            }        });        return readAllFilesPromises;    }    public storeDatasetToMemoryAndDiskHelper(        id: string, unzippedFile: any, roomsDatasets: any, coursesDatasets: any, roomsDatasetsPath: string,        resolve: any, reject: any): any {        let indexFile: object = unzippedFile.folder("rooms").files["rooms/index.htm"];        if (indexFile == null) {            throw new InsightError();        }        let promise = this.getBuildingInfoFromIndexFile(indexFile);        return promise.then((buildingInfoFromIndexFile: any) => {            try {                let readAllFilesPromises: any[] = [];                let storeAllRoomsToMemoryPromises: any[] = [];                this.readAllFilesAndStoreDatasetToMemory(id, unzippedFile, roomsDatasets, buildingInfoFromIndexFile,                    readAllFilesPromises, storeAllRoomsToMemoryPromises);                return Promise.all(readAllFilesPromises).then(() => {                    return this.storeDatasetToDisk(id, storeAllRoomsToMemoryPromises, roomsDatasets, coursesDatasets,                        roomsDatasetsPath, resolve, reject);                });            } catch (e) {                return reject(new InsightError());            }        }).catch(() => {            return reject(new InsightError());        });    }    public validateAddedDatasetResult(roomsDatasets: any, id: string): boolean {        if (!roomsDatasets[id].rooms) {            delete roomsDatasets[id];            return false;        }        if (roomsDatasets[id].rooms.length === 0) {            delete roomsDatasets[id];            return false;        }        return true;    }}
